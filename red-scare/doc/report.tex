\documentclass{tufte-handout}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{color}
\newcommand{\red}[1]{{\color{red} #1}}
\usepackage{booktabs}
\begin{document}
\section{Red Scare! Report}

by Rune Kofoed-Nissen, Lasse Lange Jakobsen, Marcus Joost, Jeppe Rask and Patrick Bassing.

\subsection{Results}

The following table gives my results for all graphs of at least 500 vertices.

\medskip
\begin{tabular}{lrrrrrr}
  \toprule
  Instance name & $n$ & A & F & M & N & S \\
  \midrule
  rusty-5762 & 5,762 & true & 16 & -- & ? & 5 \\
  wall-p-10000 & 10,000 &\\	
  $\vdots$\\
  \bottomrule
\end{tabular}
\medskip

The columns are for the problems Alternate, Few, Many, None, and Some.
For those questions where there is a reason for my inability to find a good algorithm (because the problem is hard), we wrote `?!'.
This is the case for Many, when the graph has a negative-cycle and for Some, when the graph is undirected AND has a negative cycle.
If no path is found, we wrote `-1'.
For the complete table of all results, see the tab-separated text file {\tt results.txt}.

\subsection{Methods}
%  For problem A, I solved each instance $G$ by $\cdots$\footnote{Describe what you did.
%  Use words like ``building a inverse anti-tree without self-loops where each vertex in $G$ is presented by a Strogatz--Wasserman shtump.
%  I then performed a standard longest hash sorting using the algorithm of Bronf (Algorithm 5 in [1]).''
%  Be neat, brief, and precise.}
All algorithm and graph implementations are from the JGraphT library\footnote{https://jgrapht.org/}.

For problem A, I solved each instance $G$ by removing all edges that go between vertices of same color, unless it is $s -- t$. This new graph is then run on a shortest-path algorithm. In this case Breadth-First Search (BFS).
The running time of this algorithm is $O(V + E)$, and my implementation spends $\cdots$ seconds on the instance $\cdots$ with  $n=\cdots$.

For problem F, I solved each instance $G$ by adding edge weights. Weight of 1 for edges into red vertices, and weight of 0 for all other edges. Then we run Dijkstra to get the minimum path.
The running time of this algorithm is $\cdots$, and my implementation spends $\cdots$ seconds on the instance $\cdots$ with  $n=\cdots$.

For problem N, I solved each instance $G$ by removing all red vertices from the graph, and then feeding it to a shortest-path algorithm.
The running time of this algorithm is $O(V + E)$, and my implementation spends $\cdots$ seconds on the instance $\cdots$ with  $n=\cdots$.

We solved problem S for all undirected graphs by creating a flow, and using Ford-Fulkerson. The flow graph is created by adding a new source vertex, and attaching it to both $s$ and $t$, each with capacity 1. A new target is also created, and attached to a red vertex with capacity 2. This is then done for every red vertex until a flow of size 2 is found.

We were unable to solve problem M except for the acyclic instances.
This is because, in generality, this problem is NP-hard. 
To see this, consider the following reduction from Hamiltonian paths to Many.
Let $g$ be a graph that we must find a Hamiltonian path for, with vertices $V$ and edges $E$. To reduce it so a many problem, we set $R = V$. If the result of many problem is $n$, then the graph has a Hamiltonian path if $n = |V|$.
For acyclic graphs, the problem can be solved by adding weights to the edges and running Bellman-Ford on it. Every edge going into red vertices gets a weight of -1. Every other edge gets a weight of 0. The algorithm finds the shortest path, which will include as many red vertices as possible. This is because paths with as many reds as possible, negative edges, will result in the lowest negative path.


\subsection{References}
\begin{description}
  \item[1.] \emph{APLgraphlib---A library for Basic Graph Algorithms in APL}, version 2.11, 2016, Iverson Project, {\tt github.com/iverson/APLgraphlib}.\sidenote{If you use references to code, books, or papers, be professional about it. Use whatever style you want, but be consistent.}

  \item[2.] A. Lovelace, \emph{Algorithms and Data Structures in Pascal}, Addison--Wesley 1881. 
\end{description}

\end{document}
